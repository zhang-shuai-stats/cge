*例 2.3.1  用GAMS语言对例2.2.1的投入产出模型估计直接消耗系数，建立初始模型和模拟外界政策变动

*==================================================
$title  投入产出模型(Input-output model)
*==================================================
*开头的$title指令指出标题。
*每行开始是*者为文字注释，不会被计算机读做程序指令。
*包括在$ontext 和 $offtext 之中的文字也不被GAMS读作程序。
$Ontext
这里用计算机编程语言GAMS对投入产出模型估计直接消耗系数，建立初始模型和模拟外界政策变动情况。同时对其中有关GAMS的一些基本编程程序、指令及语言作说明.
$Offtext

*以下是对第2章中例2.2.1问题求解的GAMS程序。
*====＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
* 一般，GAMS里面对指令先做宣称（declaration），然后对具体的指令定义(define）或赋值（assign）
* 指令末尾在不同情况下用分号";"结尾
* 下面首先对集合宣称命名和定义。每一个集合用符号或名字定义，不同的集合不能用相同的符号或名字
* 先以set宣称要准备对集合命名定义。然后定义集合或对集合赋值，列出集合里的元素，用斜杠包括。
* 在这里，我们对模型和SAM中所有账户的集合命名ac（英文account的前面两字母）。
* 接下去一行指令是定义子集 set i(ac)
* GAMS程序语言中英文字母不区分大写和小写
*=====＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
set ac     /sec1,sec2,labor,finaluse,total/ ;
set i(ac)  /sec1,sec2/;

*==================================================
*用alias的指令，让集合有别名，这样，在以后sigma相加符号时，可以避免指数定义的混淆
*==================================================
alias (i,j);

*=====================================================================
*将投入产出表的数据读入。
*用指令table宣称， 然后命名表格，如这里IO。括号里面包括行和列两个变量元素。注意对准每列的数据。没有数据的地方GAMS读成0。
*=====================================================================
table IO(*,*)
        sec1 sec2 finaluse  Total
sec1    200  300  100       600
sec2    150  320  530       1000
labor   250  380
Total   600 1000
;

*======================================================================
$ontext
GAMS语言中的parameter(参数)，包括参数、常数、标量、和经济学上的外生变量。它们的特点，就是数值必须外生给定。
GAMS语言中的variable（变量），是系统内部计算出来的变量。也就是经济学上的内生变量。
对参数来说，先要声明或定义所用的参数和外生变量。以"parameter"宣称，然后每行列出一个参数。参数符号须用字母开头，后面可以跟字母或数字。如B,TA,Q3，等等。
每行开头是参数符号。 空几格后可以对参数做注释说明(虽然这注释说明是可选项，但是对以后理解程序有帮助)。
两维度的参数集，如下面int(i,j)所示，括号里面第一个元素（indexed set）为行，第二个元素为列。
初始值习惯上用"0"结尾，如下面的Q0。注意数字0和字母O的差别。
整段最后用分号结尾。
$offtext
*=======================================================================
parameter
int(i,j)       intermidiate input 中间投入数量
use(i)         finaluse 最终使用
lab(i)         factor labor input 要素劳动投入
a(i,j)         direct input-output coefficients 投入产出直接消耗系数
Q0(i)          initial value for total output 总产出的初始值
;

*========================================================================
* 对参数赋值和定义 assignment for parameters
* calibration 校调(估算)参数值
* 每个等式后有分号。
* 对其它没有直接数值的参数校调估算。等号左面的参数数值由右面的已知参数数值决定。
* 右面参数数值必须在前面的程序指令中已给定或者被说明。
*========================================================================
int(i,j)=IO(i,j);
use(i) =IO(i,"finaluse");
lab(i) =IO("labor",i);
Q0(i)=IO("total",i);
a(i,j)=int(i,j)/Q0(j);
*display 打印展示数值
display int,use,lab,Q0,a;

*========================================================================
$ontext
GAMS语言中的variable变量，专指经济学上的内生变量。它们是通过程序系统要求解的变量。外生变量被称为"parameter (参数)"
先要宣称和定义内生变量，称variable。第一行用"variable"或"variables"开始宣称下面的是内生变量。
每行以一个变量符号开始。变量符号的名字必须用字母开头，后面可以跟字母或数字。符号名字后面空几格可加注释说明。整个部分的最后加分号
$offtext
*========================================================================
variable
Q(i)      total output 总产出变量;

*========================================================================
*下面设置等式。这是要对变量数值求解的等式或方程组。
*先指令 "equation" 或 "equations"， 然后对等式命名，用分号结尾。
*这里的等式取名"commodityequi"  即商品市场供求均衡
*============================================================================
equation
commodityequi(i);

*==================================================
*定义等式与要解的方程组
*要先重复已经命名的等式名字，以..结尾，然后将该等式的名字和相联系的内容写出来
*格式如下：等式名字后用两点".."注明。 然后写出等式数学内容。
*对等号的格式：=e=
*对大于号的格式：=g=
*对小于号的格式：=l=
*对CES函数的优化值求解，这里用三个等式组成的方程组
* 加减乘除:＋-*/  幂:**
*将所有方程组（线性或非线性的）等式写出来，在下一步用算法语言运行时才能解出来。
*==================================================
commodityequi(i)..
sum(j,a(i,j)*Q(j))+use(i)=e=Q(i);

*========================================================================
$ontext
程序执行前，每个变量必须有初始值。所以先要给变量赋予初始值。如果不赋值的话，缺省初始值为零。程序求解计算变量数值时，先从这个初始值开始。初始值一般是用现成数据根据模型理论计算获得。
准备求解的变量必须在变量名字后面加上一个小写字母的后缀".l"或大写字母".L"。注意不是数字1。例如的X.L=15.4。
（如果这个".L"的后缀改成" .fx"，该变量的数值就被固定了(fixed)。这时，这个变量就被迫变成了实质上的参数。如写成Y.fx=6, 变量Y变成了等于6的参数。这个写法后面有用。）
$offtext
*========================================================================
Q.l(i)=Q0(i);

*====================================================
*对上述所有程序组成的模型宣称model并取名，如IOModel
*执行模型,运行
*先用指令model,然后模型名字,然后以/all/表示所有前面叙述过的指令和设置,以规定模型的范围
*然后指令solve, 模型名字，用using来指示要用哪一个解算法来解。这里用mcp。
*====================================================
model IOmodel  /all/;
solve IOmodel using mcp;

*====================================================
*将求解的结果显示。用指令display
display Q.l

*====================================================
display  '以下部分复制初始模型 Replication'
*====================================================
*复制初始模型 replication
*复制的目的是检验计算结果是否正确
*将原来的数据扰动，填入，然后看优化后的结果是否能还原初始模型
*扰动的范围可以从小到大，以便看模型是否稳定
*下面用指令parameter，读入数据
*====================================================
parameter
repa(i,j)
repuse(i)  use these final uses
         /sec1   100
         sec2    530  /

*====================================================
*为了验证模型能够稳定地复制，变量Q的初始数值必须从原始数据的Q(i)的600和1000扰动，
*例如我们这里让部门1和2的初始数值repQ0(i)设为300和500，以便看模型运行后repQ(i)是否会收敛回600和1000。
*====================================================
repQ0(i)  部门1和2的被扰动的初始数值
         /sec1   300
          sec2   500/;
repa(i,j)=a(i,j);

variable
repQ(i);

*=====================================================
*对模型等式取新名repcommodequi，并将新的变量名字写进
*对要重现检验的模型取新名，如RepIOmodel，表示复制
*指令solve,运行和求解模型。指明这次求解的等式为 repcommodequi
*=====================================================
equation
repcommodequi(i);

repcommodequi(i)..
sum(j,repa(i,j)*repQ(j))+repuse(i)=e=repQ(i);

*下面等式就是让部门1和2的初始数值repQ.l(i)为扰动值300和500，
repQ.l(i)=repQ0(i);

model repIOmodel /repcommodequi/
solve repIOmodel using mcp;

*打印结果
display 'repQ.l， 检验结果是否和原来的产出量Q一致',   repQ.l

*=====================================================
Display ' 以下为模拟部分 Simulation'
*=====================================================
*模拟 simulation
*模拟政策或其它外界变量变化后对模型(内生)变量的影响
*假设部门2的产量增加100
*=====================================================
parameter
use2(i)  changes in the finaluse
         /sec1   0
         sec2    100  /  ;

*=====================================================
*对模型等式取新名commodityequi2，并将新的数据写进
*对模拟的模型取新名，如IOmodelSim，表示模拟
*指令solve,运行和求解模型。指明这次求解的等式为
*=====================================================
equation
commodityequi2(i);

commodityequi2(i)..
sum(j,a(i,j)*Q(j))+use2(i)=e=Q(i);

model SimIOmodel /commodityequi2/
solve SimIOmodel using mcp;

*打印最后结果 result output。单引号里面的文字说明也会打印出来
display 'Q.l， 为求解的结果',    Q.l

*=====================================================
*结束 the end
*=====================================================
